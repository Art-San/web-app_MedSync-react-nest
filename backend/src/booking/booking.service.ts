import { Booking } from './entities/booking.entity'
import { Injectable, BadRequestException } from '@nestjs/common'
import { CreateBookingDto } from './dto/create-booking.dto'
import { UpdateBookingDto } from './dto/update-booking.dto'
import { DbService } from 'src/db/db.service'
import { BaseService } from 'src/common/base.service'
import {
	parseInitData,
	validateTelegramData,
} from 'src/utils/telegram-validation'
import { BotService } from 'src/both/bot.service'

@Injectable()
export class BookingService extends BaseService {
	constructor(
		private readonly dbService: DbService,
		private readonly botService: BotService
	) {
		super(BookingService.name)
	}

	async findByIdBookLoc(bookingId: number) {
		try {
			const booking = await this.dbService.booking.findUnique({
				where: { bookingId: bookingId },
				include: {
					doctor: true,
					location: true,
					diagnostic: true,
				},
			})

			if (!booking) {
				throw new BadRequestException(
					`–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ç–∞–∫–∏–º ID: ${bookingId} –Ω–µ—Ç –≤ –ë–î`
				)
			}

			return booking
			// return { msg: 'findByIdBookLoc' }
		} catch (error) {
			this.handleException(error, 'findByIdBookLoc booking')
		}
	}

	async getBookingNotificationText(bookingId: number) {
		try {
			const booking = await this.findByIdBookLoc(bookingId)
			let fieldDoc: string
			if (booking?.doctor.doctorId) {
				fieldDoc = `üë®‚Äç‚öïÔ∏è Doctor: ${booking?.doctor.fullName}\n`
			} else if (booking?.diagnosticId) {
				fieldDoc = `üî¨ Diagnostic: ${booking?.diagnostic.typeName}\n`
			} else {
				fieldDoc = '—á–µ—Ç –Ω–µ —Ç–æ'
			}

			const notificationText = `
			üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞—à–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ. üéâ\n\n
			üìã –ó–∞–ø–∏—Å—å ‚Ññ: ${booking.bookingId}\n
			${fieldDoc}
			üìç –õ–æ–∫–∞—Ü–∏—è: ${booking.location.name}: ${booking.location.address}\n\n
			–°–ø–∞—Å–∏–±–æ, —á—Ç–æ –≤—ã–±—Ä–∞–ª–∏ –Ω–∞—à —Å–µ—Ä–≤–∏—Å! –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –∫–∞–∫–∏–µ-–ª–∏–±–æ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –≤–∞–º –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –≤—Å—Ç—Ä–µ—á—É, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ üìû.
			`

			return notificationText
			// return booking
		} catch (error) {
			this.handleException(error, 'getBookingNotificationText booking')
		}
	}
	async creationSlotDoc(dto: CreateBookingDto) {
		try {
			// Validate Telegram data
			const initData = dto.userInitData
			// if (initData && !validateTelegramData(initData)) {
			// 	throw new BadRequestException('–ù–µ–≤–µ—Ä–Ω—ã–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ')
			// }

			// –†–∞–∑–æ–±—Ä–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
			// const parsedData = parseInitData(initData)

			// –í–∞—Ä–∏–∞–Ω—Ç –¥–ª—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è
			const slot = await this.dbService.slot.findFirst({
				where: {
					startTime: dto.bookingDateTime,
					doctorId: dto.doctorId,
					locationId: dto.locationId,
				},
			})

			const slotBook = await this.dbService.booking.findFirst({
				where: {
					locationId: dto.locationId,
					bookingDateTime: dto.bookingDateTime,
				},
			})

			const date = new Date(dto.bookingDateTime)
			const hours = String(date.getHours()).padStart(2, '0')
			const minutes = String(date.getMinutes()).padStart(2, '0')
			const mount = date.getMonth()
			// console.log(34, '–º–µ—Å—è—Ü', date.getMonth())
			// console.log(34, '–≥–æ–¥', date.getFullYear())
			if (slotBook || slot) {
				throw new BadRequestException(
					`–í—Ä–µ–º—è –ø—Ä–∏–µ–º–∞ ${hours}:${minutes} —É —ç—Ç–æ–≥–æ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–æ`
				)
			}

			await this.dbService.slot.create({
				data: {
					doctorId: dto.doctorId,
					locationId: dto.locationId,
					startTime: dto.bookingDateTime,
					monthNumber: mount,
				},
			})

			// Create the booking record in the database
			const booking = await this.dbService.booking.create({
				data: {
					telegramId: dto.telegramId,
					userName: dto.userName,
					userSurname: dto.userSurname,
					userPhoneNumber: dto.userPhoneNumber,
					userEmail: dto.userEmail,
					userMessage: dto.userMessage,
					bookingDateTime: dto.bookingDateTime,
					doctorId: dto.doctorId,
					diagnosticId: dto.diagnosticId,
					locationId: dto.locationId,
				},
			})

			// –ü—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
			// if (parsedData && parsedData.user) {
			// 	const userId = JSON.parse(parsedData.user).id
			// 	// –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ sendMessage ‚Äî —ç—Ç–æ –º–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ Telegram
			// 	await this.sendMessage(userId, '–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ')
			// }
			const fieldDoc = await this.getBookingNotificationText(booking.bookingId)
			if (fieldDoc) {
				await this.botService.sendMessage(booking.telegramId, fieldDoc)
			}
			// await this.sendMessage(booking.telegramId, '–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ')

			return booking
			// return booking
		} catch (error) {
			this.handleException(error, 'byId slots')
			// throw new BadRequestException('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ')
		}
	}

	private async sendMessage(userId: string, fieldDoc: string) {
		// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ Telegram
		// –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ–∫—Å—Ç –∏–º–µ—é—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–∏–ø (—Å—Ç—Ä–æ–∫–∞)
	}

	async findAll() {
		try {
			const booking = await this.dbService.booking.findMany({
				// include: {
				// 	specialty: true,
				// 	location: true,
				// },
			})
			return booking
		} catch (error) {
			this.handleException(error, 'findAll bookings')
		}
	}
}
